---
layout: post
tags: system hardware reverse crypto
title: Reversing TL-WR840N
---
Buying cheap routers to find vulnerabilities in them

{:refdef: style="text-align: center;"}
![_config.yml]({{ site.baseurl }}/images/tplink/router.jpg)
{: refdef}

# Part 1: Acquiring the firmware
TP Link firmwares are easy to get as they are free to download online:
https://www.tp-link.com/in/support/download/tl-wr840n/
But that is a bit too easy isn't it ? Is there another way to get it ?
{:refdef: style="text-align: center;"}
![_config.yml]({{ site.baseurl }}/images/tplink/serial.jpg)
{: refdef}

Most of these devices have a serial port for debugging. Connecting to it should be trivial using a USB to UART adapter:

{:refdef: style="text-align: center;"}
![_config.yml]({{ site.baseurl }}/images/tplink/usbuart.jpg)
{: refdef}

Using this, you could potentially interrupt the boot sequence and enter a low-level shell that would allow you to do things like read the EEPROM chip at different offsets. Of course, if the goal is to easily get the firmware (over several hours because of the baud rate), then you've won !
But, still no thanks. I wanted to try something new:

{:refdef: style="text-align: center;"}
![_config.yml]({{ site.baseurl }}/images/tplink/desolder.jpg)
{: refdef}

Desoldering the EEPROM that contains the firmware was my way. If you are looking for a good reason to chose this way rather than any of the aformentioned ones, there isn't. I had just recently acquired a TL866II+, and wanted to have fun with it !
So the chip perfectly fits in the 200mm SOP8 adapter:

{:refdef: style="text-align: center;"}
![_config.yml]({{ site.baseurl }}/images/tplink/tl866.jpg)
{: refdef}

But before being able to read from it, we need to identify which kind of chip it is:

{:refdef: style="text-align: center;"}
![_config.yml]({{ site.baseurl }}/images/tplink/eeprom.jpg)
{: refdef}

We can read AH1903 25Q32CS1G, and the logo is Giga Device.
By looking for GD25Q32 in the list of devices supported by minipro, we get this: GD25Q32 @SOP8. We then dump the firmware using the Linux fork of the minipro tool, available here:  https://gitlab.com/DavidGriffith/minipro/
using the command line
```shell
root@kali:~# minipro -p GD25Q32 -r firmware.bin
Found TL866II+ 04.2.86 (0x256)
Warning: Firmware is out of date.
  Expected  04.2.118 (0x276)
  Found     04.2.86 (0x256)
Chip ID OK: 0xC84016
Reading Code...  6.99Sec  OK
```

Works like a charm! 
# Part 2: Reversing the firmware
The file is 4Mb large, and contains the following signatures:
```shell
root@kali:~# binwalk firmware.bin 

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
53488         0xD0F0          U-Boot version string, "U-Boot 1.1.3 (Jun 14 2018 - 11:06:28)"
66048         0x10200         LZMA compressed data, properties: 0x5D, dictionary size: 8388608 bytes, uncompressed size: 2986732 bytes
1048576       0x100000        Squashfs filesystem, little endian, version 4.0, compression:xz, size: 2955905 bytes, 610 inodes, blocksize: 262144 bytes, created: 2018-06-14 03:15:45
4063248       0x3E0010        XML document, version: "1.0"
```
We are mostly interested in the **squashfs**, as it contains the router's filesystem. But, we also can see that the bootloader code starts at 0xD0F0, so there may be something interesting stored at the beginning of the firmware.  
The /etc folder contains several interesting files. Notably, *default_config.xml* and *reduced_data_model.xml*. By searching for these filenmaes inside the whole squashfs, we get one interesting match: **libcmm.so**.  
Compiled code referncing encrypted files might be actually decrypting them, so we disassemble the shared object library using Ghidra.
```c
int dm_decryptFile(uint param_1,undefined4 param_2,uint param_3,int param_4)

{
  int iVar1;
  char acStack40 [8];
  int local_20;
  
  memcpy(acStack40,&encryption_key,8);
  if (param_3 < param_1) {
    cdbg_printf(8,"dm_decryptFile",0xb83,
                "Buffer exceeded, decrypt buf size is %u, but dm file size is %u",param_3,param_1);
    local_20 = 0;
  }
  else {
    local_20 = cen_desMinDo(param_2,param_1,param_4,param_3,acStack40,0);
    iVar1 = local_20;
    if (local_20 == 0) {
      cdbg_printf(8,"dm_decryptFile",0xb8a,"DES decrypt error\n");
    }
    else {
      do {
        local_20 = iVar1;
        if (((undefined *)(param_4 + local_20))[-1] != '\0') break;
        iVar1 = local_20 + -1;
      } while (local_20 != 0);
      *(undefined *)(param_4 + local_20) = 0;
    }
  }
  return local_20;
}
```
If that ain't luck...  
We have all the symbols! This makes the task much easier. So I renamed the *&encryption_key* pointer, but you can easily see that the code is:
1. Copying an 8 bytes array in a local buffer (DES key sizes are 7+1 for parity)
2. Calling *cen_desMinDo* which comes from **libcutil.so**, and is a wrapper for DES encryption functions
So we quickly get to the results using:
```shell
openssl enc -d -des-ecb -nopad -K XXXXXXXXXXXXXXXX -in default_config.xml > default_config_decrypted.xml
```
Of course, in this XML file, we expect to find loot, like:
```xml
    <StorageService>
    <UserAccount instance=1 >
    <Enable val=1 />
    <Username val=admin />
    <Password val=admin />
    <X_TP_Reference val=0 />
    <X_TP_SupperUser val=1 />
    </UserAccount>
```
We like those default credentials a lot, but they are usually widely known and/or documented (especially for cheap routers), so nothing very shocking here. The other file, reduced_data_model_decrypted.xml, contains the same kind of credentials and information, but this time they are models for the global configuration scheme.  
Another intersting thing in /etc folder: **shadow doesn't exist**  
The passwords are stored the old way, in the passwd file:
```
admin:$1$$iC.dUsGpxNNJGeOm1dFio/:0:0:root:/:/bin/sh
dropbear:x:500:500:dropbear:/var/dropbear:/bin/sh
nobody:*:0:0:nobody:/:/bin/sh
```
So *admin* seems to have a $1 (MD5) password. Let's see what hashat thinks about this:
